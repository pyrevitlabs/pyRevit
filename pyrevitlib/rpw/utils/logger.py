import logging
import os.path
import sys


DEFAULT_LOGGING_LEVEL = logging.WARNING
LOG_REC_FORMAT = "%(levelname)s: [%(name)s] %(message)s"


class LoggerWrapper(logging.Logger):
    def __init__(self, *args):
        logging.Logger.__init__(self, *args)
        self._has_errors = False

    def _log(self, level, msg, args, exc_info=None, extra=None):
        # any report other than logging.INFO level reports,
        # need to cleanup < and > character to avoid html conflict
        self._has_errors = (self._has_errors or level >= logging.ERROR)

        if not isinstance(msg, str):
            msg_str = unicode(msg)
        else:
            msg_str = msg
        # get rid of unicode characters
        msg_str = msg_str.encode('ascii', 'ignore')
        msg_str = msg_str.replace(os.path.sep, '/')
        logging.Logger._log(self,
                            level, msg_str, args, exc_info=None, extra=None)

    def getEffectiveLevel(self):
        """Overrides the parent class method to check handler.level
        instead of self.level. All loggers generated by this module use the
        same handlers. All set level methods set handler.level instead
        of self.level. This ensures that the level set on any logger affects
        all the other logger modules.
        """
        logger = self
        while logger:
            if len(logger.handlers) > 0:
                eff_level = logging.CRITICAL
                for hndlr in logger.handlers:
                    if hndlr.level < eff_level:
                        eff_level = hndlr.level
                return eff_level
            elif logger.level:
                return logger.level
            logger = logger.parent
        return logging.NOTSET

    def has_errors(self):
        return self._has_errors

    def set_level(self, level):
        self.handlers[0].setLevel(level)

    def set_info_mode(self):
        self.handlers[0].setLevel(logging.INFO)

    def set_debug_mode(self):
        self.handlers[0].setLevel(logging.DEBUG)

    def reset_level(self):
        self.handlers[0].setLevel(DEFAULT_LOGGING_LEVEL)

    def get_level(self):
        return self.level


# setting up handlers and formatters -------------------------------------------
stdout_hndlr = logging.StreamHandler(sys.stdout)
# e.g [_parser] DEBUG: Can not create command.
stdout_hndlr.setFormatter(logging.Formatter(LOG_REC_FORMAT))
stdout_hndlr.setLevel(DEFAULT_LOGGING_LEVEL)

# setting up public logger. this will be imported in with other modules --------
logging.setLoggerClass(LoggerWrapper)


loggers = {}


def get_logger(logger_name):
    if loggers.get(logger_name):
        return loggers.get(logger_name)
    else:
        logger = logging.getLogger(logger_name)    # type: LoggerWrapper
        logger.addHandler(stdout_hndlr)
        logger.propagate = False

        loggers.update({logger_name: logger})
        return logger


def logger_has_errors():
    for logger in loggers.values():
        if logger.has_errors():
            return True
    return False
